#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <pgmspace.h>

const char *ssid = "YOUR_WIFI";
const char *password = "YOUR_PASSWORD";

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

static const uint8_t worldMap[1024] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xE0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x08, 0x07, 0xFF, 0xFF, 0xE0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xC1, 0xF0, 0x7C, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFA, 0x00, 0x00, 0x7C, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x03, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x0F, 0xE0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x0F, 0xE0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF8, 0x00, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0x80, 0x00, 0x0F, 0xFF, 0x8F, 0xFC, 0x00, 0x00, 0x00, 0x70, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xCF, 0xFC, 0x00, 0x00, 0x02, 0xF0, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFD, 0x8F, 0xFC, 0x00, 0x00, 0x0E, 0xF0, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x0F, 0xC5, 0x0F, 0xFC, 0x00, 0x00, 0x0E, 0xE0, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xBE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x3E, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x3E, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xE0, 0x00, 0x3F, 0xFF, 0xFF, 0xFD, 0xFE, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x0F, 0xFF, 0xFF, 0xE1, 0xFE, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x07, 0xFF, 0xFF, 0xC0, 0xFE, 0x7F, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFE, 0x00, 0x03, 0xFF, 0xFF, 0xC0, 0x00, 0x7F, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x80, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xC0, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF0, 0x00, 0x0F, 0xFD, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF0, 0x00, 0x0F, 0xFD, 0xC0, 0x00, 0x00, 0xFF, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xE0, 0x00, 0x07, 0xFD, 0xC0, 0x00, 0x00, 0xFF, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xC0, 0x00, 0x07, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x80, 0x00, 0x07, 0xF8, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x03, 0xF8, 0x00, 0x00, 0x00, 0x03, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFE, 0x00, 0x00, 0x03, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x1F,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x1F,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1E,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1E,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

inline bool isLand(int col, int row)
{
  col = ((col % 128) + 128) % 128;
  row = constrain(row, 0, 63);
  uint8_t b = pgm_read_byte(&worldMap[row * 16 + (col >> 3)]);
  return (b >> (7 - (col & 7))) & 1;
}

struct GeoZone
{
  float latMin, latMax, lonMin, lonMax;
  const char *name;
};
static const GeoZone zones[] = {
    {36, 47, 6, 19, "ITALIA"},
    {36, 44, -9, 5, "SPAGNA"},
    {42, 51, -5, 8, "FRANCIA"},
    {47, 55, 6, 15, "GERMANIA"},
    {50, 60, -4, 2, "REGNO UNITO"},
    {55, 71, 4, 31, "SCANDINAVIA"},
    {44, 56, 14, 24, "EUROPA EST"},
    {35, 42, 20, 30, "GRECIA"},
    {36, 50, 26, 45, "TURCHIA"},
    {20, 37, 68, 97, "INDIA"},
    {18, 54, 73, 135, "CINA"},
    {30, 46, 130, 145, "GIAPPONE"},
    {10, 28, 100, 125, "SOUTHEAST ASIA"},
    {55, 77, 60, 180, "SIBERIA"},
    {15, 38, 36, 60, "ARABIA"},
    {22, 37, -6, 37, "NORD AFRICA"},
    {-35, 22, -18, 52, "AFRICA"},
    {24, 50, -125, -65, "USA"},
    {49, 72, -140, -55, "CANADA"},
    {14, 32, -118, -85, "MESSICO"},
    {-56, 14, -82, -34, "SUD AMERICA"},
    {-45, -10, 113, 155, "AUSTRALIA"},
    {60, 90, -180, 180, "ARTICO"},
    {-90, -60, -180, 180, "ANTARTIDE"},
    {20, 60, -180, -30, "OCEANO ATL N"},
    {-60, 20, -180, -30, "OCEANO ATL S"},
    {0, 60, 30, 180, "OCEANO PAC N"},
    {-60, 0, 30, 180, "OCEANO PAC S"},
    {-60, 30, 20, 80, "OCEANO IND"},
    {-90, 90, -180, 180, "OCEANO"},
};
const int NUM_ZONES = sizeof(zones) / sizeof(zones[0]);

const char *getLocationName(float lat, float lon)
{
  for (int i = 0; i < NUM_ZONES; i++)
    if (lat >= zones[i].latMin && lat <= zones[i].latMax &&
        lon >= zones[i].lonMin && lon <= zones[i].lonMax)
      return zones[i].name;
  return "OCEANO";
}

float g_lat = 41.9f, g_lon = 12.5f;
bool g_hasData = false;
float g_rot = 0.0f;
int g_blink = 0, g_ticker = 0;
unsigned long g_lastFetch = 0, g_lastAstroFetch = 0;
const unsigned long FETCH_MS = 5000, ASTRO_MS = 30000;

int g_screen = 0;
#define NUM_SCREENS 4

String g_astros = "...";
int g_astroCount = 0;

void drawGlobe()
{
  const int cx = 36, cy = 32, r = 30;
  const float rf = (float)r;
  for (int dy = -r; dy <= r; dy++)
  {
    for (int dx = -r; dx <= r; dx++)
    {
      if ((float)(dx * dx + dy * dy) > rf * rf)
        continue;
      float nx = (float)dx / rf, ny = (float)dy / rf;
      float nz = sqrtf(1.0f - nx * nx - ny * ny);
      float cosR = cosf(g_rot), sinR = sinf(g_rot);
      float rx = nx * cosR + nz * sinR, rz = -nx * sinR + nz * cosR, ry = ny;
      float lat = asinf(-ry) * RAD_TO_DEG;
      float lon = atan2f(rx, rz) * RAD_TO_DEG;
      int mc = (int)((lon + 180.0f) / 360.0f * 128.0f);
      int mr = (int)((90.0f - lat) / 180.0f * 64.0f);
      if (isLand(mc, mr))
        display.drawPixel(cx + dx, cy + dy, SSD1306_WHITE);
    }
  }
  display.drawCircle(cx, cy, r, SSD1306_WHITE);
  display.drawCircle(cx, cy, r + 1, SSD1306_WHITE);
  if (g_hasData)
  {
    float lonRel = g_lon * DEG_TO_RAD + g_rot;
    float latR = g_lat * DEG_TO_RAD;
    float x3 = cosf(latR) * sinf(lonRel);
    float y3 = -sinf(latR);
    float z3 = cosf(latR) * cosf(lonRel);
    if (z3 >= 0.0f)
    {
      int px = cx + (int)(x3 * rf), py = cy + (int)(y3 * rf);
      if ((g_blink / 10) % 2 == 0)
      {
        display.fillCircle(px, py, 2, SSD1306_WHITE);
        display.drawPixel(px + 5, py, SSD1306_WHITE);
        display.drawPixel(px - 5, py, SSD1306_WHITE);
        display.drawPixel(px, py + 5, SSD1306_WHITE);
        display.drawPixel(px, py - 5, SSD1306_WHITE);
      }
      else
      {
        display.drawCircle(px, py, 3, SSD1306_WHITE);
      }
    }
  }
  g_blink++;
}

void screenGlobe()
{
  const int X = 73;
  drawGlobe();
  display.drawLine(X - 2, 0, 127, 0, SSD1306_WHITE);
  display.drawLine(X - 2, 63, 127, 63, SSD1306_WHITE);
  display.drawLine(X - 2, 0, X - 2, 63, SSD1306_WHITE);
  display.drawLine(127, 0, 127, 63, SSD1306_WHITE);
  for (int y = 6; y < 58; y += 9)
    display.drawLine(X - 5, y, X - 2, y, SSD1306_WHITE);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(X + 1, 2);
  display.print("GLOBE");
  display.drawLine(X - 2, 11, 127, 11, SSD1306_WHITE);
  if (!g_hasData)
  {
    display.setCursor(X + 2, 20);
    display.print("LINK");
    int dots = (g_ticker / 8) % 5;
    for (int i = 0; i < dots; i++)
      display.print(".");
  }
  else
  {
    char buf[10];
    display.setCursor(X + 1, 13);
    display.print("LAT");
    display.setCursor(X + 1, 22);
    dtostrf(g_lat, 6, 1, buf);
    display.print(buf);
    display.drawLine(X - 2, 32, 127, 32, SSD1306_WHITE);
    display.setCursor(X + 1, 34);
    display.print("LON");
    display.setCursor(X + 1, 43);
    dtostrf(g_lon, 6, 1, buf);
    display.print(buf);
    display.drawLine(X - 2, 53, 127, 53, SSD1306_WHITE);
    display.setCursor(X + 1, 55);
    display.print("~408km");
    if ((g_ticker / 15) % 2 == 0)
      display.fillRect(121, 55, 4, 6, SSD1306_WHITE);
  }
}

void screenDati()
{
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.drawRect(0, 0, 128, 64, SSD1306_WHITE);
  display.drawLine(0, 10, 127, 10, SSD1306_WHITE);
  display.setCursor(30, 2);
  display.print("ISS  DATI");
  if (!g_hasData)
  {
    display.setCursor(20, 28);
    display.print("IN ATTESA...");
    return;
  }
  char buf[14];
  display.setCursor(4, 14);
  display.print("LAT:");
  dtostrf(g_lat, 9, 4, buf);
  display.setCursor(40, 14);
  display.print(buf);
  display.drawLine(0, 23, 127, 23, SSD1306_WHITE);
  display.setCursor(4, 26);
  display.print("LON:");
  dtostrf(g_lon, 9, 4, buf);
  display.setCursor(40, 26);
  display.print(buf);
  display.drawLine(0, 35, 127, 35, SSD1306_WHITE);
  display.setCursor(4, 38);
  display.print("ALT:");
  display.setCursor(40, 38);
  display.print("~408.0 km");
  display.drawLine(0, 47, 127, 47, SSD1306_WHITE);
  display.setCursor(4, 50);
  display.print("VEL:");
  display.setCursor(40, 50);
  display.print("7.66 km/s");
  if ((g_ticker / 15) % 2 == 0)
    display.fillRect(120, 56, 4, 6, SSD1306_WHITE);
}

void screenPosizione()
{
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.drawRect(0, 0, 128, 64, SSD1306_WHITE);
  display.drawLine(0, 10, 127, 10, SSD1306_WHITE);
  display.setCursor(18, 2);
  display.print("DOVE SI TROVA?");
  if (!g_hasData)
  {
    display.setCursor(20, 28);
    display.print("IN ATTESA...");
    return;
  }
  const char *loc = getLocationName(g_lat, g_lon);
  int len = strlen(loc);
  if (len > 9)
  {
    display.setTextSize(1);
    int px = max(0, (128 - len * 6) / 2);
    display.setCursor(px, 24);
    display.print(loc);
  }
  else
  {
    display.setTextSize(2);
    int px = max(0, (128 - len * 12) / 2);
    display.setCursor(px, 20);
    display.print(loc);
  }
  display.setTextSize(1);
  display.drawLine(0, 42, 127, 42, SSD1306_WHITE);
  char buf[20];
  snprintf(buf, sizeof(buf), "%.1f  %.1f", g_lat, g_lon);
  display.setCursor(20, 47);
  display.print(buf);
  bool land = isLand((int)((g_lon + 180.0f) / 360.0f * 128.0f), (int)((90.0f - g_lat) / 180.0f * 64.0f));
  display.setCursor(4, 55);
  display.print(land ? ">> TERRA" : ">> MARE");
  if ((g_ticker / 15) % 2 == 0)
    display.fillRect(120, 56, 4, 6, SSD1306_WHITE);
}

void screenInfo()
{
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.drawRect(0, 0, 128, 64, SSD1306_WHITE);
  display.drawLine(0, 10, 127, 10, SSD1306_WHITE);
  display.setCursor(14, 2);
  display.print("A BORDO ISS");

  if (g_astros == "...")
  {
    display.setCursor(20, 28);
    display.print("CARICAMENTO...");
    return;
  }

  // contatore + persone
  display.drawLine(0, 21, 127, 21, SSD1306_WHITE);
  display.setCursor(4, 13);
  display.print("A BORDO: ");
  display.print(g_astroCount);
  display.print(" persone");
  display.drawLine(0, 21, 127, 21, SSD1306_WHITE);

  // mostra UN nome alla volta, cambia ogni 2 secondi (~50 tick a 40ms)
  // splitta g_astros su "  |  " e mostra il nome corrente
  int nameIndex = (g_ticker / 50) % g_astroCount;
  String tmp = g_astros;
  String currentName = "";
  int count = 0;
  int start = 0;
  while (true)
  {
    int sep = tmp.indexOf("  |  ", start);
    if (sep == -1)
    {
      if (count == nameIndex)
        currentName = tmp.substring(start);
      break;
    }
    if (count == nameIndex)
    {
      currentName = tmp.substring(start, sep);
      break;
    }
    count++;
    start = sep + 5;
  }

  // nome centrato grande
  display.setTextSize(1);
  display.setCursor(4, 26);
  display.print("Astronauta:");
  display.setTextSize(1);
  // centra il nome
  int cx = max(0, (128 - (int)currentName.length() * 6) / 2);
  display.setCursor(cx, 36);
  display.print(currentName);

  // pallini indicatori (quanti nomi ci sono)
  int dotSpacing = min(10, 120 / max(1, g_astroCount));
  int dotStart = (128 - dotSpacing * g_astroCount) / 2;
  for (int i = 0; i < g_astroCount; i++)
  {
    int dx = dotStart + i * dotSpacing;
    if (i == nameIndex)
      display.fillCircle(dx, 47, 2, SSD1306_WHITE);
    else
      display.drawCircle(dx, 47, 1, SSD1306_WHITE);
  }

  display.drawLine(0, 52, 127, 52, SSD1306_WHITE);
  display.setCursor(4, 55);
  display.print("Orbita ~92min ~408km");
}

void showScreenName()
{
  const char *names[] = {"GLOBO", "DATI", "POSIZIONE", "INFO"};
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.drawRect(0, 20, 128, 24, SSD1306_WHITE);
  display.setCursor(10, 27);
  display.print(">> ");
  display.print(names[g_screen]);
  display.display();
  delay(400);
}

void fetchISS()
{
  if (WiFi.status() != WL_CONNECTED)
    return;
  HTTPClient http;
  http.setTimeout(3000);
  http.begin("http://api.open-notify.org/iss-now.json");
  if (http.GET() == 200)
  {
    JsonDocument doc;
    deserializeJson(doc, http.getString());
    g_lat = doc["iss_position"]["latitude"].as<float>();
    g_lon = doc["iss_position"]["longitude"].as<float>();
    g_hasData = true;
    Serial.printf("ISS lat=%.2f lon=%.2f [%s]\n", g_lat, g_lon, getLocationName(g_lat, g_lon));
  }
  http.end();
}

void fetchAstros()
{
  if (WiFi.status() != WL_CONNECTED)
    return;
  HTTPClient http;
  http.setTimeout(3000);
  http.begin("http://api.open-notify.org/astros.json");
  if (http.GET() == 200)
  {
    JsonDocument doc;
    deserializeJson(doc, http.getString());
    g_astroCount = doc["number"].as<int>();
    g_astros = "";
    JsonArray people = doc["people"].as<JsonArray>();
    for (JsonObject p : people)
    {
      if (g_astros.length() > 0)
        g_astros += "  |  ";
      g_astros += p["name"].as<String>();
    }
  }
  http.end();
}

void setup()
{
  Serial.begin(115200);
  Wire.begin(21, 19);
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C))
  {
    while (true)
      ;
  }
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.drawRect(0, 0, 128, 64, SSD1306_WHITE);
  display.drawLine(0, 18, 127, 18, SSD1306_WHITE);
  display.drawLine(0, 46, 127, 46, SSD1306_WHITE);
  display.setCursor(12, 6);
  display.print("[ISS TRACKER v3]");
  display.setCursor(8, 24);
  display.print("BOOT... WiFi link");
  display.setCursor(8, 50);
  display.print("OrbitalEye  2025");
  display.display();
  WiFi.begin(ssid, password);
  int t = 0;
  while (WiFi.status() != WL_CONNECTED && t < 40)
  {
    delay(500);
    t++;
    display.fillRect(8, 34, 112, 8, SSD1306_BLACK);
    display.setCursor(8, 34);
    for (int i = 0; i < (t % 12); i++)
      display.print(">");
    display.display();
  }
  display.fillRect(8, 24, 112, 22, SSD1306_BLACK);
  display.setCursor(8, 32);
  if (WiFi.status() == WL_CONNECTED)
  {
    display.print("WiFi  [ OK ]");
    fetchAstros();
  }
  else
  {
    display.print("WiFi  [ FAIL ]");
  }
  display.display();
  delay(800);

  Serial.println("OrbitalEye pronto!");
  Serial.println("n = schermata avanti");
  Serial.println("b = schermata indietro");
}

void loop()
{
  unsigned long now = millis();
  if (now - g_lastFetch >= FETCH_MS)
  {
    g_lastFetch = now;
    fetchISS();
  }
  if (now - g_lastAstroFetch >= ASTRO_MS)
  {
    g_lastAstroFetch = now;
    fetchAstros();
  }

  if (Serial.available())
  {
    char c = Serial.read();
    if (c == 'n')
    {
      g_screen = (g_screen + 1) % NUM_SCREENS;
      showScreenName();
    }
    if (c == 'b')
    {
      g_screen = (g_screen - 1 + NUM_SCREENS) % NUM_SCREENS;
      showScreenName();
    }
  }

  g_rot += 0.022f;
  if (g_rot > TWO_PI)
    g_rot -= TWO_PI;

  display.clearDisplay();
  switch (g_screen)
  {
  case 0:
    screenGlobe();
    break;
  case 1:
    screenDati();
    break;
  case 2:
    screenPosizione();
    break;
  case 3:
    screenInfo();
    break;
  }

  for (int i = 0; i < NUM_SCREENS; i++)
  {
    if (i == g_screen)
      display.fillCircle(2 + i * 6, 62, 1, SSD1306_WHITE);
    else
      display.drawCircle(2 + i * 6, 62, 1, SSD1306_WHITE);
  }

  display.display();
  g_ticker++;
  delay(40);
}